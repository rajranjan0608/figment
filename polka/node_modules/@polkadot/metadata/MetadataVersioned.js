import _classPrivateFieldLooseBase from "@babel/runtime/helpers/esm/classPrivateFieldLooseBase";
import _classPrivateFieldLooseKey from "@babel/runtime/helpers/esm/classPrivateFieldLooseKey";
// Copyright 2017-2021 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0
import { Struct } from '@polkadot/types/codec';
import { assert } from '@polkadot/util';
import { toV10 } from "./v9/toV10.js";
import { toV11 } from "./v10/toV11.js";
import { toV12 } from "./v11/toV12.js";
import { toLatest } from "./v12/toLatest.js";
import { MagicNumber } from "./MagicNumber.js";
import { getUniqTypes, toCallsOnly } from "./util/index.js";

var _converted = _classPrivateFieldLooseKey("converted");

var _assertVersion = _classPrivateFieldLooseKey("assertVersion");

var _getVersion = _classPrivateFieldLooseKey("getVersion");

var _metadata = _classPrivateFieldLooseKey("metadata");

/**
 * @name MetadataVersioned
 * @description
 * The versioned runtime metadata as a decoded structure
 */
export class MetadataVersioned extends Struct {
  constructor(registry, value) {
    super(registry, {
      magicNumber: MagicNumber,
      metadata: 'MetadataAll'
    }, value);
    Object.defineProperty(this, _converted, {
      writable: true,
      value: new Map()
    });
    Object.defineProperty(this, _assertVersion, {
      writable: true,
      value: version => {
        assert(this.version <= version, `Cannot convert metadata from v${this.version} to v${version}`);
        return this.version === version;
      }
    });
    Object.defineProperty(this, _getVersion, {
      writable: true,
      value: (version, fromPrev) => {
        const asCurr = `asV${version}`;
        const asPrev = `asV${version - 1}`;

        if (_classPrivateFieldLooseBase(this, _assertVersion)[_assertVersion](version)) {
          return _classPrivateFieldLooseBase(this, _metadata)[_metadata]()[asCurr];
        }

        if (!_classPrivateFieldLooseBase(this, _converted)[_converted].has(version)) {
          _classPrivateFieldLooseBase(this, _converted)[_converted].set(version, fromPrev(this.registry, this[asPrev], this.version));
        }

        return _classPrivateFieldLooseBase(this, _converted)[_converted].get(version);
      }
    });
    Object.defineProperty(this, _metadata, {
      writable: true,
      value: () => {
        return this.get('metadata');
      }
    });
  }

  /**
   * @description Returns the wrapped metadata as a limited calls-only (latest) version
   */
  get asCallsOnly() {
    return new MetadataVersioned(this.registry, {
      magicNumber: this.magicNumber,
      metadata: this.registry.createType('MetadataAll', toCallsOnly(this.registry, this.asLatest), this.version)
    });
  }
  /**
   * @description Returns the wrapped metadata as a V9 object
   */


  get asV9() {
    _classPrivateFieldLooseBase(this, _assertVersion)[_assertVersion](9);

    return _classPrivateFieldLooseBase(this, _metadata)[_metadata]().asV9;
  }
  /**
   * @description Returns the wrapped values as a V10 object
   */


  get asV10() {
    return _classPrivateFieldLooseBase(this, _getVersion)[_getVersion](10, toV10);
  }
  /**
   * @description Returns the wrapped values as a V11 object
   */


  get asV11() {
    return _classPrivateFieldLooseBase(this, _getVersion)[_getVersion](11, toV11);
  }
  /**
   * @description Returns the wrapped values as a V12 object
   */


  get asV12() {
    return _classPrivateFieldLooseBase(this, _getVersion)[_getVersion](12, toV12);
  }
  /**
   * @description Returns the wrapped values as a latest version object
   */


  get asLatest() {
    // This is non-existent & latest - applied here to do the module-specific type conversions
    return _classPrivateFieldLooseBase(this, _getVersion)[_getVersion](13, toLatest);
  }
  /**
   * @description
   */


  get magicNumber() {
    return this.get('magicNumber');
  }
  /**
   * @description the metadata version this structure represents
   */


  get version() {
    return _classPrivateFieldLooseBase(this, _metadata)[_metadata]().index;
  }

  getUniqTypes(throwError) {
    return getUniqTypes(this.registry, this.asLatest, throwError);
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    // HACK(y): ensure that we apply the aliasses if we have not done so already, this is
    // needed to ensure we have the overrides as intended (only applied in toLatest)
    // eslint-disable-next-line no-unused-expressions
    this.asLatest;
    return super.toJSON();
  }

}