// Copyright 2017-2021 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
import { assert, compactFromU8a } from '@polkadot/util';
import { combineLatest, of } from '@polkadot/x-rxjs';
import { map, take } from '@polkadot/x-rxjs/operators'; // the order and types needs to map with the all array setup below

const NumberMap = ['Zero', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten'];

function mapCapabilities({
  accountIdLength
}, [leasePeriodsPerSlot, slotRangeCount], [systemRefcount32, systemRefcountDual, systemRefcountTriple, stakingVersion], [keys]) {
  const types = {}; // AccountInfo

  if (systemRefcountTriple && systemRefcountTriple.isTrue) {
    types.AccountInfo = 'AccountInfoWithTripleRefCount';
  } else if (systemRefcountDual && systemRefcountDual.isTrue) {
    types.AccountInfo = 'AccountInfoWithDualRefCount';
  } else {
    types.AccountInfo = 'AccountInfoWithRefCount';

    if (!systemRefcount32 || systemRefcount32.isFalse) {
      types.RefCount = 'u8';
    }
  } // ValidatorPrefs


  if (stakingVersion) {
    if (stakingVersion.index >= 4) {
      // v1 = index 0, V5 = index 4
      types.ValidatorPrefs = 'ValidatorPrefsWithBlocked';
    } else {
      types.ValidatorPrefs = 'ValidatorPrefsWithCommission';
    }
  } // Keys


  if (keys) {
    try {
      const [offset, numItems] = compactFromU8a(keys);
      const tupleLength = (keys.length - offset) / numItems.toNumber();
      const numIds = tupleLength / accountIdLength;
      const numIdsRound = Math.floor(numIds);
      assert(numIds >= 2 && numIds <= 11, `Detected ${numIds} in Keys, should be >= 2 and <= 11`);

      if (numIdsRound !== numIds) {
        // Beefy?
        if ((numIdsRound - 1) * accountIdLength + 33 === tupleLength) {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          types.Keys = `SessionKeys${numIdsRound - 1}B`;
        } else {
          assert(false, `Expected integer number of keys, found ${numIds.toFixed(2)}`);
        }
      } else {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        types.Keys = `SessionKeys${numIds - 1}`;
      }
    } catch (error) {
      console.error(error);
    }
  } // auctions


  if (leasePeriodsPerSlot && slotRangeCount) {
    const _enum = [];

    for (let i = 0; leasePeriodsPerSlot.gtn(i); i++) {
      for (let j = i; leasePeriodsPerSlot.gtn(j); j++) {
        _enum.push(`${NumberMap[i]}${NumberMap[j]}`);
      }
    }

    types.SlotRange = {
      _enum
    };
    types.WinningData = `[WinningDataEntry; ${slotRangeCount.toNumber()}]`;
  }

  return types;
}

function filterEntries(original) {
  const included = original.map(c => !!c);
  const filtered = original.filter((_, index) => included[index]);
  return {
    filtered,
    included,
    original
  };
}

function extractResults(results, map) {
  let offset = -1;
  return map.included.map(isIncluded => isIncluded ? results[++offset] : null);
}
/**
 * @description Query the chain for the specific capabilities
 */


export function detectedCapabilities(api, blockHash) {
  var _api$consts$auctions, _api$consts$auctions2, _api$query$system, _api$query$system2, _api$query$system3, _api$query$staking, _api$query$session;

  const consts = filterEntries([(_api$consts$auctions = api.consts.auctions) === null || _api$consts$auctions === void 0 ? void 0 : _api$consts$auctions.leasePeriodsPerSlot, (_api$consts$auctions2 = api.consts.auctions) === null || _api$consts$auctions2 === void 0 ? void 0 : _api$consts$auctions2.slotRangeCount]);
  const queries = filterEntries([(_api$query$system = api.query.system) === null || _api$query$system === void 0 ? void 0 : _api$query$system.upgradedToU32RefCount, (_api$query$system2 = api.query.system) === null || _api$query$system2 === void 0 ? void 0 : _api$query$system2.upgradedToDualRefCount, (_api$query$system3 = api.query.system) === null || _api$query$system3 === void 0 ? void 0 : _api$query$system3.upgradedToTripleRefCount, (_api$query$staking = api.query.staking) === null || _api$query$staking === void 0 ? void 0 : _api$query$staking.storageVersion]);
  const raws = filterEntries([(_api$query$session = api.query.session) === null || _api$query$session === void 0 ? void 0 : _api$query$session.queuedKeys]);
  return combineLatest([consts.filtered.length ? blockHash // FIXME consts don't have .at as of yet...
  ? of([]) : of(consts.filtered) : of([]), queries.filtered.length ? blockHash ? combineLatest(queries.filtered.map(c => c.at(blockHash))) : api.queryMulti(queries.filtered) : of([]), raws.filtered.length ? blockHash ? combineLatest(raws.filtered.map(k => api.rpc.state.getStorage.raw(k.key(), blockHash))) : combineLatest(raws.filtered.map(k => api.rpc.state.getStorage.raw(k.key()))) : of([])]).pipe(map(([cResults, qResults, rResults]) => mapCapabilities({
    accountIdLength: api.registry.createType('AccountId').encodedLength
  }, extractResults(cResults, consts), extractResults(qResults, queries), extractResults(rResults, raws))), take(1));
}